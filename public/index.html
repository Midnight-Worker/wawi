import requests
import sqlite3
import os

DB_PATH = "products.db"


def init_db():
    """Erzeugt eine lokale SQLite-DB, falls noch nicht vorhanden."""
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS products (
            ean TEXT PRIMARY KEY,
            name TEXT,
            brand TEXT,
            source TEXT
        )
    """)
    conn.commit()
    conn.close()


class Api:
    def __init__(self):
        init_db()

    # -------- Hilfsfunktionen für lokale DB ----------

    def _db_get_product(self, ean: str):
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT ean, name, brand, source FROM products WHERE ean = ?", (ean,))
        row = cur.fetchone()
        conn.close()
        if row:
            return {
                "ean": row[0],
                "name": row[1],
                "brand": row[2],
                "source": row[3] or "local"
            }
        return None

    def _db_save_product(self, ean: str, name: str, brand: str, source: str = "local"):
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("""
            INSERT OR REPLACE INTO products (ean, name, brand, source)
            VALUES (?, ?, ?, ?)
        """, (ean, name, brand, source))
        conn.commit()
        conn.close()

    # Diese Methode kannst du auch verwenden, um OPD-Dumps zu importieren.
    # z.B. CSV einlesen und _db_save_product(...) aufrufen.

    # -------- API für pywebview / JS ----------

    def lookup_ean(self, ean):
        """
        Lookup-Kette:
        1. Lokale/OPD-Datenbank (SQLite)
        2. OpenFoodFacts (online)
        3. sonst: "nicht gefunden" -> Frontend zeigt Eingabefelder an
        """

        def make_result(source, ean, name=None, brand=None, ok=True, message=None):
            return {
                "ok": ok,
                "ean": ean,
                "name": name or "",
                "brand": brand or "",
                "source": source,
                "message": message or "",
            }

        # ---- 1) Lokale / OPD-DB ----
        try:
            local_product = self._db_get_product(ean)
            if local_product:
                return make_result(
                    source=local_product["source"],
                    ean=local_product["ean"],
                    name=local_product["name"],
                    brand=local_product["brand"],
                )
        except Exception as e:
            print(f"Lokale DB Fehler: {e}")

        # ---- 2) OpenFoodFacts ----
        try:
            url = f"https://world.openfoodfacts.org/api/v0/product/{ean}.json"
            resp = requests.get(url, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                if data.get("status") == 1:
                    product = data.get("product", {})
                    name = product.get("product_name", "")
                    brand = ", ".join(product.get("brands_tags", [])) or product.get("brands", "")
                    # in lokale DB übernehmen (Quelle: openfoodfacts)
                    self._db_save_product(ean, name, brand, source="openfoodfacts")
                    return make_result(
                        source="openfoodfacts",
                        ean=ean,
                        name=name,
                        brand=brand,
                    )
        except Exception as e:
            print(f"OpenFoodFacts Fehler: {e}")

        # ---- 3) Nichts gefunden ----
        return make_result(
            source="none",
            ean=ean,
            ok=False,
            message="Kein Produkt gefunden. Bitte Daten manuell eingeben und speichern.",
        )

    def save_product(self, ean, name, brand):
        """
        Vom Frontend aufgerufen, wenn der Nutzer manuell ein Produkt eingibt.
        """
        try:
            self._db_save_product(ean, name, brand, source="manual")
            return {"ok": True, "message": "Produkt gespeichert."}
        except Exception as e:
            return {"ok": False, "message": f"Fehler beim Speichern: {e}"}

